"""
Automated tests for dynamic resource loading in the displayer system.

Test Architecture:
- Auto-discovers DisplayerItems with get_required_resources() methods
- Renders each item to HTML (reusing test_displayer_auto.py fixtures)
- Validates that required resources appear in generated HTML
- Validates that unexpected resources do NOT appear in HTML

Test Coverage:
- Resource registration during item instantiation
- CSS/JS/CDN inclusion in rendered HTML
- Resource isolation (no cross-contamination between items)
- ResourceRegistry reset behavior

Integration:
- Shares Flask test app with test_displayer_auto.py
- Uses same output directory (tests/core/output/)
- HTML files generated by test_displayer_auto.py are verified here
"""

import pytest
import os
from typing import List, Dict
from src.modules import displayer


# ---------------------------------------------------------------------------
# Test Configuration
# ---------------------------------------------------------------------------

TEST_OUTPUT_DIR = os.path.join(os.path.dirname(__file__), "output")

# Mapping of vendor libraries to their expected file patterns in HTML
VENDOR_RESOURCE_PATTERNS = {
    'filepond': {
        'css': ['filepond.min.css', 'filepond-plugin'],
        'js': ['filepond.min.js', 'filepond-plugin', 'filepond-init.js']
    },
    'tinymce': {
        'js': ['tinymce.min.js', 'tinymce-init.js']
    },
    'apexcharts': {
        'cdn': ['cdn.jsdelivr.net/npm/apexcharts']
    },
    'fullcalendar': {
        'js': ['fullcalendar']
    },
    'datatables': {
        'css': ['datatables.min.css'],
        'js': ['datatables.min.js', 'datatables-init.js']
    },
    'sweetalert': {
        'css': ['sweetalert2.min.css'],
        'js': ['sweetalert2.all.min.js']
    }
}


# ---------------------------------------------------------------------------
# Helper Functions
# ---------------------------------------------------------------------------

def check_html_for_resources(item_class_name: str, required_vendors: List[str]) -> Dict:
    """
    Check if generated HTML contains expected resources for given vendors.
    
    :param item_class_name: Name of DisplayerItem class (e.g., 'DisplayerItemInputFile')
    :param required_vendors: List of vendor names that should be loaded (e.g., ['filepond'])
    :return: Dict with 'success', 'missing', 'unexpected' keys
    """
    html_file = os.path.join(TEST_OUTPUT_DIR, f"item_{item_class_name}.html")
    
    if not os.path.exists(html_file):
        return {
            'success': False,
            'error': f"HTML file not found: {html_file}",
            'missing': [],
            'unexpected': []
        }
    
    with open(html_file, 'r', encoding='utf-8') as f:
        html = f.read()
    
    # Build expected patterns based on required vendors
    expected_patterns = []
    for vendor in required_vendors:
        if vendor in VENDOR_RESOURCE_PATTERNS:
            vendor_patterns = VENDOR_RESOURCE_PATTERNS[vendor]
            for resource_type in ['css', 'js', 'cdn']:
                if resource_type in vendor_patterns:
                    expected_patterns.extend(vendor_patterns[resource_type])
    
    # Define globally-loaded resources (always present in base.j2)
    # These are loaded for framework-wide features (scheduler, popups, etc.)
    GLOBAL_RESOURCES = ['sweetalert2.min.css', 'sweetalert2.all.min.js']
    
    # Build unexpected patterns (all other vendors, excluding global resources)
    unexpected_patterns = []
    all_vendors = set(VENDOR_RESOURCE_PATTERNS.keys())
    unexpected_vendors = all_vendors - set(required_vendors)
    for vendor in unexpected_vendors:
        vendor_patterns = VENDOR_RESOURCE_PATTERNS[vendor]
        for resource_type in ['css', 'js', 'cdn']:
            if resource_type in vendor_patterns:
                # Filter out global resources from unexpected list
                patterns = [p for p in vendor_patterns[resource_type] if p not in GLOBAL_RESOURCES]
                unexpected_patterns.extend(patterns)
    
    # Check for expected patterns
    missing = [pattern for pattern in expected_patterns if pattern not in html]
    
    # Check for unexpected patterns
    found_unexpected = [pattern for pattern in unexpected_patterns if pattern in html]
    
    return {
        'success': len(missing) == 0 and len(found_unexpected) == 0,
        'missing': missing,
        'unexpected': found_unexpected
    }


def get_items_with_resources() -> List[type]:
    """
    Auto-discover all DisplayerItem classes that have get_required_resources() method.
    
    :return: List of DisplayerItem classes that require resources
    """
    items_with_resources = []
    
    # Get all DisplayerItem classes from all categories
    all_categories = displayer.DisplayerCategory.get_all()
    for category_name, item_classes in all_categories.items():  # type: ignore
        for item_class in item_classes:
            # Check if class has get_required_resources method
            if hasattr(item_class, 'get_required_resources'):
                try:
                    # Call it to see if it returns non-empty list
                    resources = item_class.get_required_resources()
                    if resources:
                        items_with_resources.append(item_class)
                except Exception:
                    # Skip classes where get_required_resources() fails
                    pass
    
    return items_with_resources

@pytest.mark.parametrize("item_class", get_items_with_resources())
def test_item_resources_in_html(item_class: type) -> None:
    """
    For each DisplayerItem with get_required_resources():
    1. Determine what resources it requires
    2. Load the pre-generated HTML file (from test_displayer_auto)
    3. Verify required resources are present in HTML
    4. Verify unexpected resources are NOT present in HTML
    
    Note: This test depends on test_displayer_auto.py running first to generate HTML files.
    """
    # Get required resources for this item
    required_vendors = item_class.get_required_resources()
    assert required_vendors, f"{item_class.__name__} should return non-empty resources list"
    
    # Check HTML for resources
    result = check_html_for_resources(item_class.__name__, required_vendors)
    
    # Provide detailed failure message
    if not result['success']:
        error_msg = f"\nResource validation failed for {item_class.__name__}:"
        
        if 'error' in result:
            error_msg += f"\n  Error: {result['error']}"
        
        if result['missing']:
            error_msg += f"\n  Missing resources: {result['missing']}"
        
        if result['unexpected']:
            error_msg += f"\n  Unexpected resources found: {result['unexpected']}"
        
        pytest.fail(error_msg)


def test_resource_isolation():
    """
    Test that items requiring different resources don't contaminate each other.
    
    This verifies the ResourceRegistry.reset() behavior works correctly.
    """
    from src.modules.displayer import Displayer, DisplayerLayout, Layouts, ResourceRegistry
    
    # Get two items with different resource requirements
    items = get_items_with_resources()
    if len(items) < 2:
        pytest.skip("Need at least 2 items with resources for isolation test")
    
    # Find items with different resources
    item_class_1 = None
    item_class_2 = None
    
    for item in items:
        resources = item.get_required_resources()
        if not item_class_1:
            item_class_1 = (item, resources)
        elif set(resources) != set(item_class_1[1]):
            item_class_2 = (item, resources)
            break
    
    if not item_class_1 or not item_class_2:
        pytest.skip("Could not find items with different resource requirements")
    
    # Test item 1
    disp1 = Displayer()
    disp1.add_generic("Test1")
    layout1 = DisplayerLayout(Layouts.VERTICAL, [12])
    disp1.add_master_layout(layout1)
    item1 = item_class_1[0].instantiate_test()
    disp1.add_display_item(item1)
    
    # Verify only item1's resources are registered
    for vendor in item_class_1[1]:
        assert vendor in ResourceRegistry._required_vendors, \
            f"Expected {vendor} for {item_class_1[0].__name__}"
    
    # Test item 2 (should reset and only have its resources)
    disp2 = Displayer()  # This should reset the registry
    disp2.add_generic("Test2")
    layout2 = DisplayerLayout(Layouts.VERTICAL, [12])
    disp2.add_master_layout(layout2)
    item2 = item_class_2[0].instantiate_test()
    disp2.add_display_item(item2)
    
    # Verify only item2's resources are registered (item1's should be gone)
    for vendor in item_class_2[1]:
        assert vendor in ResourceRegistry._required_vendors, \
            f"Expected {vendor} for {item_class_2[0].__name__}"
    
    # Verify item1's resources are NOT in registry anymore
    for vendor in item_class_1[1]:
        if vendor not in item_class_2[1]:  # Unless item2 also uses it
            assert vendor not in ResourceRegistry._required_vendors, \
                f"Item 1 vendor {vendor} should have been cleared by reset"
